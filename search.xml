<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【C语言】注释转换(C注释转换为C++注释)]]></title>
    <url>%2F2018%2F11%2F07%2F%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91%E6%B3%A8%E9%87%8A%E8%BD%AC%E6%8D%A2-C%E6%B3%A8%E9%87%8A%E8%BD%AC%E6%8D%A2%E4%B8%BAC-%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[C语言注释的风格123456789101112131415161718192021/*void CommentConvert(FILE* pfRead, FILE* pfWrite)&#123; State state = NUL_STATE;//程序当前的状态 while (state != END_STATE) &#123; switch (state) &#123; case NUL_STATE: DoNulState(pfRead, pfWrite, &amp;state); break; case C_STATE: DoCState(pfRead, pfWrite, &amp;state); break; case CPP_STATE: DoCppState(pfRead, pfWrite, &amp;state); break; case END_STATE: break; &#125; &#125;&#125;*/ C++语言注释的风格123456789101112131415161718192021//void CommentConvert(FILE* pfRead, FILE* pfWrite)//&#123;// State state = NUL_STATE;//程序当前的状态// while (state != END_STATE)// &#123;// switch (state)// &#123;// case NUL_STATE:// DoNulState(pfRead, pfWrite, &amp;state);// break;// case C_STATE:// DoCState(pfRead, pfWrite, &amp;state);// break;// case CPP_STATE:// DoCppState(pfRead, pfWrite, &amp;state);// break;// case END_STATE:// break;// &#125;// &#125;//&#125; 如何转换举一个注释转换的例子在input.c文件里写出以下代码123456789101112131415161718192021222324252627// 1.一般情况int num = 0;/* int i = 0; */// 2.换行问题/* int i = 0; */int j = 0;/* int i = 0; */int j = 0;// 3.匹配问题/*int i = 0;/*xxxxx*/// 4.多行注释问题/*int i=0;int j = 0;int k = 0;*/int k = 0;// 5.连续注释问题/**//**/// 6.连续的**/问题/***/// 7.C++注释问题// /*xxxxxxxxxxxx*/ 头文件123456789101112131415161718192021#ifndef __COMMENT_CONVERT_H__#define __COMMENT_CONVERT_H__#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef enum State//枚举法表示操作选项&#123; NUL_STATE,//无状态 C_STATE,//C注释状态 CPP_STATE,//C++注释状态 END_STATE//结束状态&#125;State;void DoNulState(FILE* pfRead, FILE* pfWrite, State* ps);void DoCState(FILE* pfRead, FILE* pfWrite, State* ps);void DoCppState(FILE* pfRead, FILE* pfWrite, State* ps);void CommentConvert(FILE* pfRead, FILE* pfWrite);#endif //__COMMENT_CONVERT_H__ 转换过程读写文件 123456789101112131415161718192021222324252627282930#define _CRT_SECURE_NO_WARNINGS 1#include &quot;CommentConvert.h&quot;void test()&#123; FILE * pfRead = NULL; FILE * pfWrite = NULL; pfRead = fopen(&quot;input.c&quot;, &quot;r&quot;); if (pfRead == NULL) &#123; perror(&quot;Error open for read&quot;); exit(EXIT_FAILURE); &#125; pfWrite = fopen(&quot;output.c&quot;, &quot;w&quot;); if (pfWrite == NULL) &#123; perror(&quot;Error open for write&quot;); exit(EXIT_FAILURE); &#125; //注释转换 CommentConvert(pfRead, pfWrite); fclose(pfRead); pfRead = NULL; fclose(pfWrite); pfWrite = NULL;&#125;int main()&#123; test(); return 0;&#125; 4种状态的循环 123456789101112131415161718192021void CommentConvert(FILE* pfRead, FILE* pfWrite)&#123; State state = NUL_STATE;//程序当前的状态 while (state != END_STATE) &#123; switch (state) &#123; case NUL_STATE: DoNulState(pfRead, pfWrite, &amp;state); break; case C_STATE: DoCState(pfRead, pfWrite, &amp;state); break; case CPP_STATE: DoCppState(pfRead, pfWrite, &amp;state); break; case END_STATE: break; &#125; &#125;&#125; 3种状态的具体操作无状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445void DoNulState(FILE* pfRead, FILE* pfWrite, State* ps)//无状态&#123; int first = fgetc(pfRead); switch (first) &#123; case &apos;/&apos;: &#123; int second = fgetc(pfRead); switch (second) &#123; case&apos;*&apos;: &#123; fputc(&apos;/&apos;, pfWrite); fputc(&apos;/&apos;, pfWrite); *ps = C_STATE; &#125; break; case &apos;/&apos;: &#123; fputc(first, pfWrite); fputc(second, pfWrite); *ps = CPP_STATE; &#125; break; default: &#123; fputc(first, pfWrite); fputc(second, pfWrite); &#125; break; &#125; &#125; break; case &apos;EOF&apos;: &#123; *ps = END_STATE; &#125; break; default: &#123; fputc(first, pfWrite); &#125; break; &#125;&#125; C状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void DoCState(FILE* pfRead, FILE* pfWrite, State* ps)//C状态&#123; int first = fgetc(pfRead); switch (first) &#123; case &apos;*&apos;: &#123; int second = fgetc(pfRead); switch (second) &#123; case &apos;/&apos;: &#123; int third = 0; *ps = NUL_STATE; third = fgetc(pfRead); if (third != &apos;\n&apos;) &#123; fputc(&apos;\n&apos;, pfWrite); ungetc(third, pfRead); &#125; else &#123; fputc(third, pfWrite); &#125; &#125; break; case &apos;*&apos;: &#123; int third = 0; *ps = NUL_STATE; third = fgetc(pfRead); if (third = &apos;/&apos;) fputc(first, pfWrite); &#125; break; default: &#123; fputc(first, pfWrite); fputc(second, pfWrite); &#125; break; &#125; &#125; break; case &apos;\n&apos;: &#123; fputc(first, pfWrite); fputc(&apos;/&apos;, pfWrite); fputc(&apos;/&apos;, pfWrite); &#125; break; default: &#123; fputc(first, pfWrite); &#125; break; &#125;&#125; C++状态 1234567891011121314151617181920212223void DoCppState(FILE* pfRead, FILE* pfWrite, State* ps)//C++状态&#123; int first = fgetc(pfRead); switch (first) &#123; case &apos;EOF&apos;: &#123; *ps = END_STATE; &#125; break; case &apos;\n&apos;: &#123; fputc(first, pfWrite); *ps = NUL_STATE; &#125; break; default: &#123; fputc(first, pfWrite); &#125; break; &#125;&#125; 转换结果比较如有不足之处，欢迎指正！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[【链表面试题】合并两个有序链表, 合并后依然有序]]></title>
    <url>%2F2018%2F11%2F07%2F%E3%80%90%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%90%88%E5%B9%B6%E5%90%8E%E4%BE%9D%E7%84%B6%E6%9C%89%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 合并两个有序链表 SListNode * MergeOrderedList(SListNode *p1First, SListNode *p2First)&#123; SListNode*cur1 = p1First; SListNode*cur2 = p2First; SListNode*result = NULL;//结果链表 SListNode*tail = NULL;//结果链表中的最后一个结点，方便尾插 SListNode*next;//保存遍历过程中的下一个结点 while (cur1 != NULL &amp;&amp; cur2 != NULL) &#123; if (cur1-&gt;data &lt;= cur2-&gt;data) &#123; //应该取链表1的结点 if (result != NULL) &#123; //结果链表不为空，直接在最后一个结点上做插入 //保存链表1的下一个结点，让循环继续 next = cur1-&gt;Next; //插入过程 tail-&gt;Next = cur1; cur1-&gt;Next = NULL; //保存新的最后一个结点 tail = cur1; cur1 = next; &#125; else &#123; //保存链表1的下一个结点，让循环继续 next = cur1-&gt;Next; result = cur1; cur1-&gt;Next = NULL; //保存新的最后一个结点 tail = cur1; cur1 = next; &#125; &#125; else &#123; //应该取链表2的结点 if (result != NULL) &#123; //结果链表不为空，直接在最后一个结点上做插入 //保存链表2的下一个结点，让循环继续 next = cur2-&gt;Next; //插入过程 tail-&gt;Next = cur2; cur2-&gt;Next = NULL; //保存新的最后一个结点 tail = cur2; cur2 = next; &#125; else &#123; //保存链表1的下一个结点，让循环继续 next = cur2-&gt;Next; result = cur2; cur2-&gt;Next = NULL; //保存新的最后一个结点 tail = cur2; cur2 = next; &#125; &#125; &#125; //一个链表为空了 if (cur1 == NULL) &#123; tail-&gt;Next = cur2; &#125; if (cur2 == NULL) &#123; tail-&gt;Next = cur1; &#125; return result;&#125; 测试用例12345678910111213141516void TestMerge()&#123; SListNode*List1 = NULL, *List2 = NULL; SListPushBack(&amp;List1, 1); SListPushBack(&amp;List1, 1); SListPushBack(&amp;List1, 3); SListPushBack(&amp;List1, 4); SListPushBack(&amp;List1, 6); SListPushBack(&amp;List2, 1); SListPushBack(&amp;List2, 2); SListPushBack(&amp;List2, 3); SListNode*result = MergeOrderedList(List1, List2); SListPrint(result);&#125; 结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
